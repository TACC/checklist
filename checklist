#!/bin/bash
# Checklist is a rename and rewrite the python sanitycheck tool "at TACC".
# It "checks" the same user environment components, but is a complete rewrite 
# in the BASH shell scripting language, performing checks in different ways
# and reporting is somewhat different.
# Nevertheless, it is versioned 4.0 in recognition of the previous work.

# One important design concept of 4.0 is that
# it simplifies how to include your own scripts for checking.
# Written by Kent Milfeld
# 
# END COMMENTS -- Do Not Remove, Alter or Duplicate

#     ---------- checklist shell functions ----------

# === 01_SSH ===
01_SSH(){
# 1.) Check permission on ~/.ssh directory
# 2.) Check permission on ~/.ssh/*_id.pub 
# 3.) Check permission on ~/.ssh/*_id
# 4.) Check permission on ~/.ssh/authorized_keys
# 5.) Make sure *_id.pub is in authorized_keys

#TODO What if multiple keys?
#TODO Exist later if 0 keys found (check directory permissions
#TODO Exist later if OK with multiple keys
#                                 2025-08-01 Kent Milfeld

  [[ $# != 1 ]] && O=N    #Command line options T=terse,v=Verbose, default Normal
  [[ $1 == t ]] && O=T
  [[ $1 == v ]] && O=V

space10='          ' tab=$space10
STATUS=0

i=0
pub_key_files=( id_ed25519.pub id_rsa.pub )

echo "SSH setup"

output=`ls $HOME/.ssh/*.pub`
if [[ $? != 0 ]]; then
  echo " Could not find any public key (of form \*pub)."
  exit 1
else   #determine key type
  for file in ${pub_key_files[@]}; do
    if [[ $output =~ $file  ]]; then
       pub_keys+=($file)
    fi
  done
fi
 if [[ ${#pub_keys[@]}  == 1 ]]; then
   if [[ $O == N ]] || [[ $O == V ]]; then
    echo "$tab Found public  key ${pub_keys[0]}" && pub_key=${pub_keys[0]}
   fi
   [[ $O == T ]]  && T_string="Found public key ${pub_keys[0]}"
 fi
 [[ ${#pub_keys[@]}  == 0 ]] && echo "$tab Found NO public key (searched: ${pub_key_files[@]})" && exit 1
#[[ ${#pub_keys[@]} -gt 1 ]] && echo " Found Multiple public key ${pub_keys[@]}." && exit 1

 pub_key=${pub_keys[0]}
priv_key=${pub_key%%.pub}

output=`ls $HOME/.ssh/$priv_key`
if [[ $? == 0 ]]; then
   [[ $O == N ]] || [[ $O == V ]] && 
     echo "$tab Found private key $priv_key"
   [[ $O == T ]] && 
     T_string="$T_string and private key $priv_key" 
else
  echo "$tab Could NOT find private key $priv_key."; exit 1
fi

filenames=( .ssh $priv_key $pub_key authorized_keys )
pathnames=( $HOME/.ssh $HOME/.ssh/$priv_key $HOME/.ssh/$pub_key $HOME/.ssh/authorized_keys )
 perms=(     drwx------ -rw-------           -rw-r--r--          -rw------- )
#perms=(     .rwx------ .rw-------           .rw-r--r--          .rw------- ) #tests
set_perms=( 700        600                  644                 600 )
 #echo ${pathnames[@]}
 #echo ${perms[@]}
 #echo ${set_perms[@]}
 #echo ==================================================


check_perm(){

  pathname=${CL_PATHNAME-$1} 
      perm=${CL_PERM-$2} 
   setperm=${CL_SETPERM-$1} 

  local O=$4
  return_status=0

  stat_perm=`stat -c %A ${pathnames[$i]}`
  status=$?
  
  name=`basename ${pathnames[$i]}`
  short_pathname=$(echo ${pathnames[$i]} | sed 's@'$HOME'@$HOME@')
 #echo short_pathname=$short_pathname
  
  
  if [[ $stat_perm == ${perms[$i]} ]]; then
    [[ $O == N ]] || [[ $O == V ]] &&
    printf "%s %-40s %s\n" "$tab" "Permissions correct for $name:" "${perms[$i]}"
  else
    return_status=1
    echo "$tab FAILED Permissions on $short_pathname are incorrect."
    echo "$tab   Found:     $stat_perm permissions for $name"
    echo "$tab   Should be: ${perms[$i]}"
    echo "$tab   Execute:   chmod ${set_perms[$i]} $short_pathname"
  fi

 #[[ $space == "" ]] && pass_space=$tab #first time no space
  space=$tab #first time no space

}

for i in ${!pathnames[@]}; do
   check_perm ${pathnames[$i]} ${perms[$i]} ${set_perms[$i]} $O
   [[ $return_status != 0 ]] && STATUS=$return_status
done

if [[ $O == T ]] && [[ $STATUS == 0 ]]; then
   echo "$tab $T_string" 
   echo "$tab Permissions OK for: ${filenames[@]}" 
fi

exit $STATUS
}
 

# === 02_Storage ===
02_Storage(){

# 1.) Determine if USER STORAGE DIRS (US_DIRS) are defined
#     HOME, WORK, SCRATCH are critical, not defined is failure
# 2.) Check Minimum Permissions (dwrx)
# 3.) Write test

## WRITE/READ test

##TODO  STOCKYARD on all sys (including vista stockyard=work)
##TODO  What about aptainer and singularity

[[ $# != 1 ]] && O=N    #Command line options T=terse,v=Verbose, default Normal
[[ $1 == t ]] && O=T
[[ $1 == v ]] && O=V

space10='          '
STATUS=0

host_name=`hostname -A`
for sys in frontera vista stampede ls6; do
  [[ $host_name =~ $sys ]] && AT_TACC=yes TACC_SYS=$sys
done
TACC_SYS=stampede

if [[ $AT_TACC == yes ]]; then
   USER_STORAGE_DIRS=( HOME  SCRATCH WORK  STOCKYARD )
  USER_STORAGE_PERMS=( drwx  drwx    drwx  drwx     )
  CRITICAL_STORAGE_DIRS=( HOME )

 #echo "STORAGE Environment Variable Definition & Directory Perms." 
  echo "STORAGE ENV VARS & PERMS"
  tab=$space10

  # Determine if variables are defined
  for i in ${!USER_STORAGE_DIRS[@]}; do
      user_dir=${USER_STORAGE_DIRS[$i]}
      if [[ ! -z ${!user_dir} ]]; then
         [[ $O == N ]] || [[ $O == V ]] &&
         printf "%s %-9s Variable  is defined.\n" "$tab" $user_dir
         found_pathnames+=(${!user_dir})
         found_storage_dirs+=($user_dir)
         found_storage_perms+=(${USER_STORAGE_PERMS[@]})

         defined+=($user_dir)
      else
         [[ $O == N ]] || [[ $O == V ]] &&
         printf "%s %-9s Variable NOT defined.\n" "$tab" $user_dir
        #[[ $STATUS != 1 ]] && STATUS=3  #  retain critical status
        #[[ ${CRITICAL_STORAGE_DIRS[@]} =~ $user_dir ]] && STATUS=1
         STATUS=1

         undefined+=($user_dir)
      fi  
  done
  if [[ $O == T ]]; then 
    [[ ${#defined[@]}   -gt 0 ]] &&   def_part="DEFINED Vars: ${defined[@]}"
    [[ ${#undefined[@]} -gt 0 ]] && undef_part="UNDEFINED VARS: ${undefined[@]} - "
    echo "$tab ${undef_part}$def_part"
  fi

  if [[ ${#found_storage_dirs[@]} == 0 ]]; then
    echo "$tab None of the following User Storage Variables are defined:"
    echo "$tab    (${USER_STORAGE_DIRS[@]})."
    STATUS=1  #redundant, JIC some directories become only warnings in future
  fi

  # Check USER permission of directories for which variables are defined.
  if [[ ${#found_storage_dirs[@]} -gt 0 ]]; then
    for i in ${!found_storage_dirs[@]}; do
       user_dir=${found_storage_dirs[$i]}
       stat_perm=`stat -c %A ${found_pathnames[$i]}`
       status=$? 
       if [[ $stat_perm =~ ^${found_storage_perms[$i]} ]]; then
          [[ $O == N ]] || [[ $O == V ]] &&
          printf "%s %-9s directory USER permissions are valid (%s)..\n" \
                 "$tab" $user_dir ${found_storage_perms[$i]}
          valid+=($user_dir)
       else
          [[ $O == N ]] || [[ $O == V ]] &&
          printf "%s %-9s directory USER permissions (%s) NOT valid (required: %s).\n" \
                 "$tab" $user_dir $stat_perm ${found_storage_perms[$i]}
          STATUS=1
          invalid+=($user_dir)
      fi  
    done
  fi
  if [[ $O == T ]]; then 
    [[ ${#valid[@]}   -gt 0 ]] &&   val_part="VALID Perms: ${valid[@]}"
    [[ ${#invalid[@]} -gt 0 ]] && inval_part="INVALID PERMS: ${invalid[@]} - "
    echo "$tab ${inval_part}$val_part"
  fi

  # test writing/reading from USER directories (that mount is correct)
  if [[ ${#found_storage_dirs[@]} -gt 0 ]]; then
    for i in ${!found_storage_dirs[@]}; do
       user_dir=${found_storage_dirs[$i]}
    done

  fi
fi
exit $STATUS
}
 

# === 03_Quotas ===
03_Quotas(){


[[ $# != 1 ]] && O=N    #Command line options T=terse,v=Verbose, default Normal
[[ $1 == t ]] && O=T
[[ $1 == v ]] && O=V

space10='          '  tab=""
host_name=`hostname -A`

for sys in ls6 frontera stampede3 vista; do
  [[ $host_name =~ $sys ]] && AT_TACC=yes TACC_SYS=$sys
done

if [[ $AT_TACC == yes ]]; then
  [[ $TACC_SYS == frontera  ]] && filesystems=(/home1 /work)
  [[ $TACC_SYS == ls6       ]] && filesystems=(/home1 /work)
  [[ $TACC_SYS == vista     ]] && filesystems=(/home1 /work)
  [[ $TACC_SYS == stampede3 ]] && filesystems=(/home1 /work)
fi

OS=`uname`
output=`df --version >/dev/null 2>&1`; status=$?
if [[ $OS == Linux ]]; then
  df_opts=-BG          # On Centos/Rocky
elif [[ $OS == Darwin ]]; then
  df_opts=-g           # On MacOS
else
  echo " ERROR (internal): Don't know OS for df command.  Bailing"
  exit 1
fi

#Check use of local files systems
local_disks=(/tmp)
if [[ $OS == Darwin ]]; then                #Uses a single df for space and inode
  echo "STORAGE QUOTAS"
  tab=$space10

  for file_sys in ${local_disks[@]}; do
    df_flds=(`df $df_opts $file_sys | tail -n 1`)
  
    space_used_no=${df_flds[4]%\%}
    inode_used_no=${df_flds[7]%\%}
  
    [[ $((100-space_used_no)) -lt 11 ]] || [[ $((100-inode_used_no)) -lt 11 ]] &&
    echo "$tab WARNING: space or inode availability low on $file_sys" 
  
    printf "%s %-8s [SPACE: %4s%% available of %4sGB]  [INODES: %4s%% free (%7s)]\n" \
         "$tab" \
         $file_sys $((100-space_used_no)) ${df_flds[1]} \
                   $((100-inode_used_no)) ${df_flds[6]}
  done

elif [[ $OS == Linux ]]; then                       # requires executing 2 df's: space and inodes
  echo "STORAGE QUOTAS"
  tab=$space10

  for file_sys in ${local_disks[@]}; do
    df_space_flds=(`df    $df_opts $file_sys | tail -n 1`)
    df_inode_flds=(`df -i $df_opts $file_sys | tail -n 1`)
  
    space_used_no=${df_space_flds[4]%\%} 
    inode_used_no=${df_inode_flds[4]%\%}
  
    [[ $((100-space_used_no)) -lt 11 ]] || [[ $((100-inode_used_no)) -lt 11 ]] &&
    echo "$tab WARNING: space or inode availability low on $file_sys" 
  
#   printf "%-8s [SPACE: %4s%% available of %4sGB]  [INODES: %4s%% free (%7s)]\n" \
    printf "%s %-8s [SPACE: %4s%% available of %4s]  [INODES: %4s%% free (%7s)]\n" \
           "$tab" \
           $file_sys $((100-space_used_no)) ${df_space_flds[1]} \
                     $((100-inode_used_no)) ${df_inode_flds[1]}
  done
fi

if [[ $AT_TACC == yes ]]; then
  tab=$space10
  for fs in ${filesystems[@]}; do
    do_cmd=lfs
    [[ $fs =~ home1 ]] && [[ $TACC_SYS == vista     ]] && do_cmd=quota
    [[ $fs =~ home1 ]] && [[ $TACC_SYS == stampede3 ]] && do_cmd=quota
    [[ $fs =~ home1 ]] && [[ $TACC_SYS == ls6       ]] && do_cmd=quota

    if [[ $do_cmd =~ lfs ]] ; then
      common_out=(`lfs quota   -u $USER  $fs | sed -n '3p'`)
      [[ ${common_out[4]} == "-" ]] && common_out[4]=0     #make grace 0 if "-"
      [[ ${common_out[8]} == "-" ]] && common_out[8]=0

      common_out[1]=`echo $(echo "scale=2; ${common_out[1]}/1048576"  | bc -l)` #kbytes to gbytes
      common_out[2]=`echo $(echo "scale=2; ${common_out[2]}/1048576"  | bc -l)`
      common_out[3]=`echo $(echo "scale=2; ${common_out[3]}/1048576"  | bc -l)`
      percent_used_space=`echo $(echo "scale=2; 100*${common_out[1]}/${common_out[3]}"  | bc -l)`
      percent_used_inode=`echo $(echo "scale=2; 100*${common_out[5]}/${common_out[7]}"  | bc -l)`

      # Report at login:
      # Disk         Usage (GB)     Limit    %Used   File Usage       Limit   %Used |
      # /scratch         1657.0       0.0     0.00      7120972           0    0.00 |
      #Vista $ lfs quota   -u $USER  /work | sed -n '3p'
      #/work 450798756       0 1073741824       - 2999996       0 3000000       -

      #first time write header
      [[ ${filesystems[0]} == $fs ]] && \
      echo "$tab Disk         Usage (GB)     Limit    %Used   File Count      Limit  %Used "

      printf  "%s %-13s %9s %9s %8s %12s %10s %6s\n" \
              "$tab" \
               ${common_out[0]} \
               ${common_out[1]} ${common_out[3]} $percent_used_space \
               ${common_out[5]} ${common_out[7]} $percent_used_inode
    fi

    if [[ $do_cmd =~ quota ]] ; then
      out=(`quota -w -f $fs | sed -n '3p'`)

                  # filesys   used      quota     limit grace used      quota     limit grace
      common_out=(${fs} ${out[1]} ${out[2]} ${out[3]} 0 ${out[4]} ${out[5]} ${out[6]} 0)

      common_out[1]=`echo $(echo "scale=2; ${common_out[1]}/1048576"  | bc -l)` #kbytes to gbytes
      common_out[2]=`echo $(echo "scale=2; ${common_out[2]}/1048576"  | bc -l)`
      common_out[3]=`echo $(echo "scale=2; ${common_out[3]}/1048576"  | bc -l)`
      percent_used_space=`echo $(echo "scale=2; 100*${common_out[1]}/${common_out[3]}"  | bc -l)`
      if [[ ${common_out[7]} != 0 ]]; then  #fix for home1 on ls6
        percent_used_inode=`echo $(echo "scale=2; 100*${common_out[5]}/${common_out[7]}"  | bc -l)`
      else
        percent_used_inode="-"
        common_out[7]="-"
      fi

      echo "$tab Disk         Usage (GB)     Limit    %Used   File Count      Limit  %Used "
      printf  "%s %-13s %9s %9s %8s %12s %10s %6s\n" \
              "$tab" \
               ${common_out[0]} \
               ${common_out[1]} ${common_out[3]} $percent_used_space \
               ${common_out[5]} ${common_out[7]} $percent_used_inode
    fi
  done
fi
#Disk quotas for user milfeld (uid 1117): 
#     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
#192.168.16.21:/vista/home1 23126004       0 24414060          282610       0  500000        
#Disk quotas for usr milfeld (uid 1117):
#     Filesystem  kbytes   quota   limit   grace   files   quota   limit   grace
#          /work 450798756       0 1073741824       - 2999996       0 3000000       -
#

# df INFO from LINUS
#$ df  -BG /tmp   #vistat
#Filesystem                  1G-blocks  Used Available Use% Mounted on
#/dev/mapper/rootvg01-lv_tmp      286G    3G      283G   1% /tmp
#$  df -i -BG /tmp
#Filesystem                     Inodes IUsed     IFree IUse% Mounted on
#/dev/mapper/rootvg01-lv_tmp 149704704 13790 149690914    1% /tmp

#exit 0


#  space_used_MB=${limits[0]}
# space_limit_MB=${limits[2]}
#  inode_used=${limits[3]}
# inode_limit=${limits[5]}
# 
# if [[ $space_limit_MB -gt 0.00 ]]; then
#   if [[ $space_used_MB/$space_limit_MB -gt 0.95 ]]; then
#     echo " Space used in $FS is above 95%."
#   else
#     echo "  ${percent}% of $percent of  12345 MB in $FS (limit: $ 
#     #   At 90% of $FS quota (17GB used, 240GB available)
#     #   At 90% of $FS user quota (17/240 GB used/avail)
#   fi
# else
#   echo " No space limit on $FS."
#   exit 0
# fi

     
# v====== TACC COMMENTS ======v

# Vista $ quota -f /scratch
#Disk quotas for user milfeld (uid 1117): 
#     Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
#192.168.16.21:/vista/scratch
#                1737490432       0 9765624217600         7120972       0       0   

#Vistat $ quota -f /home1
#Disk quotas for user milfeld (uid 1117): 
#    Filesystem  blocks   quota   limit   grace   files   quota   limit   grace
#192.168.16.21:/vista/home1
#                23125632       0 24414060          282526       0  500000     

# Vistat Login Disk information
#------------------------ Disk quotas for user milfeld -------------------------
#| Disk         Usage (GB)     Limit    %Used   File Usage       Limit   %Used |
#| /scratch         1657.0       0.0     0.00      7120972           0    0.00 |
#| /home1*            22.1      23.3    94.72       282526      500000   56.51 |
#| /work*            429.9    1024.0    41.98      2999996     3000000  100.00 |
#-------------------------------------------------------------------------------
}
 

# === 04_Modules ===
04_Modules(){
# Check if module executable/function is available.
# If @TACC Check if TACC module is loaded.
# If @TACC Check if a default compiler system  is available.
#                                 2025-08-01 Kent Milfeld
# TODO If @TACC Check if a default MPI      library is available.
# 
# TODO 1.) Determine module type
# TODO 2.) what about csh (alias module)
# TODO 2.) means identifying login shell

[[ $# != 1 ]] && O=N    #Command line options T=terse,v=Verbose, default Normal
[[ $1 == t ]] && O=T 
[[ $1 == v ]] && O=V 

space10='          '  tab=""

  host_name=`hostname -A`
  for sys in frontera vista stampede ls6; do
    [[ $host_name =~ $sys ]] && AT_TACC=yes TACC_SYS=$sys
  done

  if [[ $AT_TACC == yes ]]; then
    TACC_compiler_families=( nvidia intel oneAPI llvm gcc )
  fi

  echo "MODULES Access and Loads"
  tab=$space10


  output=`type module`
  if [[ $? == 0 ]]; then
     cmd=executable
     [[ $output =~ "module is a function" ]] && cmd=function
     [[ $O == V ]] || [[ $O == N ]] &&
     echo "$tab The module $cmd was found."
  else
     echo " No path/type for module command found."
     echo " Check to make system initialization is defining the module function."
     exit 1
  fi

if [[ $AT_TACC == yes ]]; then

  output=`ml is-loaded TACC`
  if [[ $? == 0 ]]; then
    [[ $O == V ]] || [[ $O == N ]] &&
    printf "%s %-7s module is loaded.\n" "$tab" "TACC"
    T_string="TACC module loaded. " 
  else
    echo "$tab TACC module is NOT loaded-- a requirement for TACC environments."
    exit 1
  fi
  
  type=no_default
  output=$(module describe 2>&1)
  if [[ "$output" =~ "Collection \"default\" contains:" ]]; then

    for comp in ${TACC_compiler_families[@]}; do   #( nvidia intel oneAPI llvm gcc)
      reg="\\b${comp}\\b"
      [[ $output =~ $reg  ]] &&  compilers+=($comp) #&& echo FOUND $comp -- ${compilers[@]}
    done

    if [[ ${#compilers[@]} ==  1 ]]; then
      type=has_default
      [[ $O == V ]] || [[ $O == N ]] &&
      printf "%s %-7s compiler module is in the default module group and is loaded.\n" "$tab" ${compilers[0]}
      T_string="$T_string Module ${compilers[0]} is the default compiler module."
    fi
    [[ ${#compilers[@]} ==  0 ]] && echo "$tab No compiler found in default system system module." &&  exit 1
    [[ ${#compilers[@]} -gt 1 ]] && echo "$tab More than 1 compiler system found in the default module." && 
                                      echo "$tab Only a single compiler system can be loaded in a module env." &&
                                      exit 1
  fi
  
  if [[ $type != has_default ]]; then
    for comp in ${TACC_compiler_families[@]}; do   #( nvidia intel oneAPI llvm gcc)
      module is-loaded $comp #>/dev/null 2>&1 
      [[ $? == 0 ]] &&  loaded_compilers+=($comp)
    done
  
    if [[ $O == V ]] || [[ $O == N ]]; then
      [[ ${#loaded_compilers[@]} ==  1 ]] && printf "%s %-7s module is the loaded compiler system.\n" \
                                          "$tab" ${loaded_compilers[0]}
    fi
    [[   ${#loaded_compilers[@]} ==  0 ]] && echo "$tab No loaded compiler system found." &&  exit 1
    [[   ${#loaded_compilers[@]} -gt 1 ]] && echo "$tab More than 1 compiler system found in the loaded module." && 
                                          echo "$tab Only a single compiler system can be loaded in a module env." &&
                                          exit 1
  fi
  [[ $O == T ]] &&
     echo "$tab $T_string"

fi
exit 0

#  TACC_compiler_families=( nvidia intel oneAPI llvm gcc)
#vista $ ml describe
#Collection "default" contains: 
#   1) nvidia    2) nvpl    3) ucc    4) ucx    5) openmpi    6) cmake    7) xalt    8) TACC
}
 

# === 05_Compilers ===
05_Compilers(){
#  Determine which family of compilers are accessible
#  with the present Environment.
#  1.) Searches for compilers sets (families).
#  2.) Incomplete is reported as a failure.
#  3.) Expected to find gcc on all systems (failure otherwise)
#  4.) At TACC, warning if module cmd/function not found 
#      (reported as error in Module check).
#  5.) At TACC failur4 is no default compiler system.
#                                 2025-08-01 Kent Milfeld

[[ $# != 1 ]] && O=N    #Command line options T=terse,v=Verbose, default Normal
[[ $1 == t ]] && O=T 
[[ $1 == v ]] && O=V 

space='          ' tab=""
STATUS=0

host_name=`hostname -A`
for sys in frontera vista stampede ls6; do
  [[ $host_name =~ $sys ]] && AT_TACC=yes TACC_SYS=$sys
done

compiler_families=(nvidia intel oneAPI llvm gcc)

declare -A sets
sets[nvidia]="nvc nvc++ nvfortran"
 sets[intel]="icc icpc ifort"
sets[oneAPI]="icx icpx ifx"
  sets[llvm]="clang clang++ flang"
   sets[gcc]="gcc g++ gfortran"    #ALWAYS keep gcc last


#Check for all known compilers
echo "COMPILERS Searching Compiler Families (${compiler_families[@]})"
tab=$space

for family in ${compiler_families[@]}; do
  set=( ${sets[$family]} )
  found=()
  for compiler in ${set[@]}; do
      output=`type $compiler 2>&1`
      if [[ $? == 0 ]]; then 
        found+=($compiler)
      fi
  done

  flat_found="${found[@]}"
    flat_set="${set[@]}"
  if [[ ${#found[@]} == 0 ]]; then
     if [[ $O == V ]]; then
       printf "%s %-6s family NOT AVAILABLE in present module environment.\n" "$tab" $family
       [[ $family == gcc ]] && printf "%s       family is required!\n" "$tab" && STATUS=1
     fi
     [[ $family == gcc ]] && found_gcc_family=no
  fi

  if [[ ${#found[@]} == 1 ]] || [[ ${#found[@]} == 2 ]]; then
     if [[ $O == N ]] || [[ $O == V ]]; then
       printf "%s %-6s family SUBSET AVAILABLE in present module environment (%s).\n"  "$tab"  $family  "$flat_found"
       [[ $family == gcc ]] && printf "%s       Complete family is required!\n" "$tab" "$flat_set"  && STATUS=1
     fi
     [[ $family == gcc ]] && found_gcc_subset=yes && gcc_subset=($flat_found)
     found_subsets+=("${family}: $flat_found")
  fi

  if [[ ${#found[@]} == 3 ]] || [[ ${#found[@]} == 1 ]]; then
     if [[ $O == N ]] || [[ $O == V ]]; then
       printf '%s %-6s family in present module environment (%s).\n'  "$tab"  $family  "$flat_found"
     fi
     found_all_3+=("${family}: $flat_found") 
  fi

  if [[ ${compiler_families[-1]} == $family ]]; then
    if [[ $O == T ]]; then
      if [[ ${#found_subsets[@]} == 0 ]] && [[ ${#found_all_3[@]} == 0 ]];  then
        echo "$tab COMPILERS NONE FOUND (searched ${compiler_families[@]})"
        exit 1
      fi
      if [[ $found_gcc_family == no ]]; then
        echo "$tab COMPILERS GCC compilers not present."
        exit 1
      fi
      if [[ $found_gcc_subset == yes ]]; then
        echo "$tab COMPILERS Only subset of GCC compilers found ($gcc_subset)."
        exit 1
      fi
      if [[ ${#found_all_3[@]} == 0 ]]; then
        echo "$tab COMPILERS No complete complier set found. (Incomplete sets: ${found_subsets[@]})"
        exit 1
      fi
      [[ ${#found_subsets[@]} -gt 0 ]] && FSETS="${found_subsets[@]}" && echo HERE9
      echo "$tab COMPILERS ${found_all_3[@]} $FSETS" #(subsets: ${found_subsets[@]})
    fi 
  fi

done

exit $STATUS
}
 

# === 06_Allocations ===
06_Allocations(){

[[ $# != 1 ]] && O=N    #Command line options T=terse,v=Verbose, default Normal
[[ $1 == t ]] && O=T 
[[ $1 == v ]] && O=V 

space10='          '  tab=""
STATUS=0

host_name=`hostname -A`
for sys in frontera vista stampede ls6; do
  [[ $host_name =~ $sys ]] && AT_TACC=yes TACC_SYS=$sys
done

                  #milfeld:*:1117:825112:milfeld:/home1/00770/milfeld:/bin/bash
user_info=`getent passwd $USER`
IFS=":" read -ra usr_etc_pwd <<< "$user_info"  # put fields in /usr_etc_pwd array

user=${usr_etc_pwd[0]}
 uid=${usr_etc_pwd[2]}
 gid=${usr_etc_pwd[3]}
home=${usr_etc_pwd[5]}
login_shell=${usr_etc_pwd[6]}

if [[ $AT_TACC == yes ]]; then
  TACC_ACC_DIR="/usr/local/etc/"
  [[ $sys == ls4 ]] && TACC_ACC_DIR=/sge_common/default/acct/map/
         proj_map=$TACC_ACC_DIR/project.map
     projuser_map=$TACC_ACC_DIR/projectuser.map
  projbalance_map=$TACC_ACC_DIR/projectbalance.map
        usage_map=$TACC_ACC_DIR/usage.map

  projects=( $(grep -E "^${user}\\b" $projuser_map) ) #projuser_map
  status=$?
  projects=("${projects[@]:1}")  #remove 1st element, user name
  if [[ $status == 0 ]]; then
    if [[ $O == N ]] || [[ $O == V ]] ; then
      echo "PROJECTS found (IDs ${projects[@]}, repectively): "
      tab=$space10
    fi
    if [[ $O == T ]] ; then
      echo "PROJECTS of user $USER."
      tab=$space10
    fi
  else
    echo "No Projects found for user $user."
    exit 1
  fi

  valid_count=0 expired_count=0
  for proj_id in ${projects[@]}; do
    name_id=( $(grep -E " $proj_id\\b" $proj_map) )  #$proj_map
    proj_name=${name_id[0]}

    
    usage_line=( $(grep -E "^$proj_name:" $usage_map) )  #$usage_map
    IFS=":" read -ra usage <<< "$usage_line"
    start_date=${usage[2]}
      end_date=${usage[3]}
      allocate=${usage[4]}
          used=${usage[5]}
       balance=${usage[6]}

    if [[ ${#usage[@]} -ne 7 ]]; then
        echo -e "$tab“  WARNING: invalid account line for $proj_name:\n" \
                "$tab          $usage_line"
                  #MCB22024:Vista:2022-04-26:2027-01-31:10000:3.496:9996.504
        STATUS=3
    else
      valid_count=$(( valid_count + 1 ))
      today=`date +%F`
      today_no=$(awk -F'-' '{printf("%4d%02d%02d\n",$1,$2,$3)}' <<< `date +%F`)
        end_no=$(awk -F'-' '{printf("%4d%02d%02d\n",$1,$2,$3)}' <<< $end_date)

      if [[ $today_no -gt $end_no ]]; then
        expired_count=$(( expired_count + 1 ))
        if [[ $O == N ]] || [[ $O == V ]] ; then
          echo -e "$tab  EXPIRED: Project $proj_name has expired ($end_date)\n"
        fi
        exp_proj+=($proj_name)
      else
        if [[ $O == N ]] || [[ $O == V ]] ; then
          printf  "%s ACTIVE : %8s (SUs Alloc:Used:Bal:Exp) %8s %8.0f %8.0f %s \n" \
                   "$tab" "$proj_name" "${allocate}" "${used}" "${balance}" "$end_date"
        fi
          balance=${balance%.*}
          act_proj+=( $proj_name:Bal=$balance)
      fi

      if [[ $proj_id == ${projects[-1]} ]] && [[ $O == T ]] ; then
    # if [[ $O == T ]] ; then
         [[ ${#exp_proj[@]} -gt 0 ]] && EXP="Expired: ${exp_proj[@]}"
         echo "$tab Active: ${act_proj[@]} $EXP" 
      fi
    fi
  done

  if [[ $valid_count -gt 0 ]]; then 
    if [[ $expired_count -eq $valid_count ]]; then
      echo -e " FAIL: All valid projects are expired.\n"   #FAILURE
      exit 1
    fi
    [[ $expired_count -gt 0 ]] && exit 3                    #WARNING
  fi

  exit 0

fi
}
 

# === 07_Batch ===
07_Batch(){

#TODO:
# determine what the scheduler
# show queues, and determine status  (si with status)

[[ $# != 1 ]] && O=N    #Command line options T=terse,v=Verbose, default Normal
[[ $1 == t ]] && O=T 
[[ $1 == v ]] && O=V 

space10='          '
tab=$space10

type sbatch >& /dev/null
[[ $? == 0 ]] && batch_sched+=(SLURM         ) && sched_cmds=(sbatch scancel squeue)
type qsub >& /dev/null
[[ $? == 0 ]] && batch_sched+=(PBS_TORQUE_SGE) && sched_cmds=(qsub qdel qstat)
type bsub >& /dev/null
[[ $? == 0 ]] && batch_sched+=(LSF           ) && sched_cmds=(bsub bkill bjobs)
type llsubmit >& /dev/null
[[ $? == 0 ]] && batch_sched+=(LOADLEVELER   ) && sched_cmds=(llsubmit llcancel llq)

#batch_sched=()
if [[ ${#batch_sched[@]} == 0 ]]; then
   echo "No BATCH MANAGER FOUND. Checked for: "
   echo "$tab SLURM,  PBS_TORQUE_SGE, LSF  and LOADLEVER with commands:"
   echo "$tab sbatch, qsub,           bsub,    llsubmit, respectively."
   exit 1
elif [[ ${#batch_sched[@]} == 1 ]]; then
   echo "BATCH manager is ${batch_sched[0]}"
fi

#host_name=`hostname -A`
#for sys in frontera vista stampede ls6; do
#  [[ $host_name =~ $sys ]] && AT_TACC=yes TACC_SYS=$sys
#done

#if [[ $AT_TACC == yes ]]; then
#  sched_cmds=(sbatch squeue scancel)
#  [[ $TACC_SYS == ls4 ]] && sched_cmds=(qsub qstat qdel)
#else
#  sched_cmds=(qsub qstat qdel)
#fi

for sched_cmd in ${sched_cmds[@]}; do
  output=`type $sched_cmd`
  if [[ $? == 0 ]]; then 
    found_cmds+=($sched_cmd)
  else
    not_found_cmds+=($sched_cmd)
  fi
done

if [[ ${#sched_cmds[@]} -eq ${#found_cmds[@]} ]]; then
   echo "$tab All BATCH scheduler command(s) found: ${found_cmds[@]}"
else
   echo "$tab Only found BATCH scheduler command(s): ${found_cmds[@]}"
   echo "$tab Could not find the BATCH command(s): ${not_found_cmds[@]}"
   exit 1
fi


#q_status=(`sinfo --noheader -o "%20P %5a"`)
q_status=`sinfo --noheader -o "$tab   %10P %5a"`
queue_count=`sinfo --noheader -o "$tab   %10P %5a" | wc -l`
up_count=`echo $q_status | grep -o up | wc -l`

echo "$tab PARTITION  AVAILABILITY"
echo "$q_status"

[[ $up_count == 0 ]]               && echo "$tab ALL QUEUES ARE NOT up"  && exit 1
[[ $up_count != $queue_count ]] && echo "$tab NOT ALL QUEUES ARE up." && exit 3

exit 0
}
 

# === 08_Reservations ===
08_Reservations(){

#Report SLURM Reservations -- Very Specific to TACC
# AT TACC SLURM reservations are made by username, projects, and groupIDs.
#
# 1.) Get user's projects.
# 2.) Find all reservations
# 3.) terse   report: only report reservation names if user/acct is on a reservation

# 3.) normal  report: Reservation details of all reservations are reported in 90 columns
#     ( RESERVATION_NAME  STATE PARTITION [START M-D h:m] \
#                               [Wait:|Used:]  DURATION [User:|Acct])

# 3.) verbose report: More reservation details of all reservations are reported +90 columns
#     ( RESERVATION_NAME    STATE   PARTITION NODES [START  M-D h:m] \
#                                   [Wait:|Used:]  DURATION [Usr:|Acct:|Grp])

##TODO Include group_id reservations (seldom done) in report.
##TODO Fix Node value in REMORA
## $RN    ${r[$i,11]} $PART      ${r[$i,5]} "$start_time" "$WAITorUSED_Duration" "$UAG"

#                                                       2025-08-07 Written by Kent Milfeld

  [[ $# != 1 ]] && O=N    #Command line options T=terse,v=Verbose, default Normal
  [[ $1 == t ]] && O=T
  [[ $1 == v ]] && O=V

  space10='          '  tab=""

  host_name=`hostname -A`
  for sys in frontera vista stampede ls6; do
    [[ $host_name =~ $sys ]] && AT_TACC=yes TACC_SYS=$sys
  done

if [[ $AT_TACC == yes ]]; then
                       TACC_ACC_DIR="/usr/local/etc/"
  [[ $sys == ls4 ]] && TACC_ACC_DIR=/sge_common/default/acct/map/
             proj_map=$TACC_ACC_DIR/project.map
         projuser_map=$TACC_ACC_DIR/projectuser.map
      projbalance_map=$TACC_ACC_DIR/projectbalance.map
            usage_map=$TACC_ACC_DIR/usage.map
  proj_ids=( $(grep -E "^${USER}\\b" $projuser_map) ) #projuser_map
  status=$?

  proj_ids=("${proj_ids[@]:1}")  #remove 1st element, user name
  if [[ $status != 0 ]]; then
    echo "Projects NON FOUND -- Site ERROR."
    exit 1
  fi

  for proj_id in ${proj_ids[@]}; do
    name_id=( $(grep -E " $proj_id\\b" $proj_map) )  #$proj_map
    proj_names+=(${name_id[0]})
  done
fi

#Utility Functions
  get_waitRused_duration() {
     #   Time now, and reservation start and end time
     #   Determine Wait or reservation Used time, and duration
     #   in "W: DDD-HH:mm" or "U: DDD-HH:mm" fir Wait/Uses time
     #   plus  "DDD-HH:mm" for Duration. If DDD=0, DDD- not included.
     #   e.g U: 1-01:02   2-00:00 == Used 1day, 1hr, 2min of 2day reservation.
         d1=$(date -d "$1" +%s) #now
         d2=$(date -d "$2" +%s) #start
         d3=$(date -d "$3" +%s) #end
  
     #Time to Wait or Time Used 
      delta=$(( d2-d1))
          d=delta
      [[ $delta -lt 0 ]] && d=$(( -delta ))
  
     days=$(( d/86400 ))
        h=$(( d-(days*86400) ))
      hrs=$(( h/3600 ))
        m=$(( h-(hrs*3600) ))
      min=$(( m/60 ))
      sec=$(( m-(min*60) ))
  
     #reservation (r) duration 
      rdelta=$(( d3-d2))
          rd=rdelta
     rdays=$(( rd/86400 ))
       rh=$(( rd-(rdays*86400) ))
     rhrs=$(( rh/3600 ))
       rm=$(( rh-(rhrs*3600) ))
     rmin=$(( rm/60 ))
     rsec=$(( rm-(rmin*60) ))
  
     [[ $rdays -gt 0 ]] && res_dur=$(printf " %3d-%02d:%02d\n" $rdays $rhrs $rmin )
     [[ $rdays -eq 0 ]] && res_dur=$(printf "     %02d:%02d\n"        $rhrs $rmin )
     res_frmt="%10s"
  
     if [[ $delta -lt 0 ]]; then
        [[ $days -ne 0 ]] && printf "U:%3d-%02d:%02d $res_frmt\n" $days $hrs $min $res_dur #$sec
        [[ $days -eq 0 ]] && printf "U:    %02d:%02d $res_frmt\n"       $hrs $min $res_dur #$sec
     else
        [[ $days -ne 0 ]] && printf "W:%3d-%02d:%02d $res_frmt\n" $days $hrs $min $res_dur #$sec
        [[ $days -eq 0 ]] && printf "W:    %02d:%02d $res_frmt\n"       $hrs $min $res_dur #$sec
     fi  
  }
  
  ndx_order_by_val_sort(){
      # create array of "index + value" 
      # | sort lines on value (k2) numerically (n) 
      # | remove values (using space as delimiter)
    local args=($@)
    for (( i = 0; i < ${#args[@]}; ++i)); do
      echo "$i ${args[i]}"
    done | sort -k2n | cut -d' ' -f1 
  }

### END Functions    

   if [[ -z $IDEV_RES_INPUT ]]; then
      readarray -t R_lines <<< "$( scontrol show res --oneliner )"
   else
      readarray -t R_lines <<< "$( cat $IDEV_RES_INPUT )"
      echo " -> Reading TEST reservations from IDEV_RES_INPUT=$IDEV_RES_INPUT"
   fi

   no_res_txt=""
   [[ ${R_lines[0]} =~ "No reservations in the system" ]] && R_lines=() && no_res_txt="No reservations in the system"
   nres=${#R_lines[@]}

   R_keys=(ReservationName StartTime EndTime Duration Nodes NodeCnt CoreCnt PartitionName Users Accounts Groups State Flags)
   #             0             1       2        3      4       5      6         7          8        9     10     11    12

   # r is a hash table for reservations. 
   # r[$i,$j] i=reservation line index (each reservation is read as a line
   #          j=value index, j index corresponds to the R_keys[$j] key name
  
   declare -A r    
   starts=()
   for i in "${!R_lines[@]}"; do
      res=(${R_lines[$i]})
      for k in ${!R_keys[@]}; do r[$i,$k]="null"; done   #initialize r to "(null)"
   
      for index in ${!R_keys[@]}; do
      for pair  in ${res[@]}; do
        if [[ $pair =~ ${R_keys[$index]} ]]; then
           val=$pair
           val=${val##*=}  #remove <key>= from <key>=<value> pair
           [[ $val ==    ""    ]] && val="null"
           [[ $val == '(null)' ]] && val="null"
           r[$i,$index]=$val
           break
        fi
      done
      done
   
      # get start time as seconds since 1970-01-01 00:00:00 UTC, for ordering reservations by start time
      starts[$i]=$( date -d "${r[$i,1]}" +%s )

   done 
   
   if [[ ! -z $IDEV_DEBUG ]];then 
     for i in ${!R_lines[@]}; do
       for j in ${!R_keys[@]};do 
         [[ $j -eq 0 ]] && echo " -> Reservation ${r[$i,0]} ----------"
         printf "   %2d %15s %s\n" $j ${R_keys[$j]} ${r[$i,$j]}; 
       done
     done
     [[ ${#starts[@]} -ne 0 ]] && echo "   Reservations start-time order: ${starts[@]}"
   fi

   # Use this index array if the scontrol show res  lines are not ordered in time
   #readarray -t ndx_ResStartOrder <<<"$(ndx_order_by_val_sort ${starts[@]})"
   ndx_ResStartOrder=($(ndx_order_by_val_sort ${starts[@]}))

   ## July 27, 2024 replacement ^^
    
   RN_lmax=16

   now_yy=$(date +%y)
   now=$(date +"%Y-%m-%dT%H:%M:%S")

   if [[ $nres -ne 0 ]]; then
      if [[ $O == V ]]; then
        echo "RESERVATIONS for All users."
        tab=$space10
        echo "$tab RESERVATION_NAME    STATE   PARTITION NODES [START  M-D h:m] [Wait:|Used:]  DURATION [Usr:|Acct:|Grp]"
      fi
      if [[ $O == N ]]; then
        echo "RESERVATIONS for $USER or projects of user."
        tab=$space10
        echo "$tab RESERVATION_NAME  STATE PARTITION [START M-D h:m] [Wait:|Used:]  DURATION [Usr:|Acct:|G:]"
      fi
   fi
   [[ $nres -eq 0 ]] &&
      echo "RESERVATIONS NO reservation appear on the system." && exit 0

   my_ress=() 
   for i in ${ndx_ResStartOrder[@]}; do
     start=${r[$i,1]}
       end=${r[$i,2]}

     start_yy=${r[$i,1]:2:2}      # gets yy out of YYyy-...
  
     date -d "$start" +%s >& /dev/null
     [[ $? -ne 0 ]] && start=2020-01-01T00:00:00 now=2022-09-26T01:00:00 end=2022-09-26T01:00:00  #D999
########  WHAT IS THIS RM  KENT
     
     WAITorUSED_Duration=$( get_waitRused_duration $now $start $end )
     
     UAG="NO ACCESS"
     [[ ${r[$i,10]} != null ]] && UAG="G: ${r[$i,10]}"  && uses_grp_access=yes
     [[ ${r[$i,8]}  != null ]] && UAG="U: ${r[$i,8]}"
     [[ ${r[$i,9]}  != null ]] && UAG="${string}A: ${r[$i,9]}"
  
     PART=${r[$i,7]}
     [[ ${r[$i,7]} == null ]] && PART="        -"   # don't put null if no partition
     
     # Change format of start time: YYYY-MM-DDThh:mm:ss => MM-DD hh:mm
     start_time=$( echo ${r[$i,1]} |  sed  's/^.....\(.....\)T\(.....\).*/\1 \2/' ) 
     [[ $now_yy -ne $start_yy ]] && start_time=${start_yy}-$start_time
###
     RN=${r[$i,0]} n=${#RN}
#echo "---------------------------------------$RN. n=$n."
     if [[ $n -gt $RN_lmax ]]; then
         nbase=$(( RN_lmax - 6))
      c1=${RN:0:$nbase}  # first  nbase chars  (base)
      c2='..'           # middle 2 chars, short elipse
         from=$((n-4)) to=$((n-1))
      c3=${RN:$from:$to} # last 4 char
      RN="$c1$c2$c3"
##     echo "c1:$c1.  c2:$c2.  c3:$c3."
     fi

     if [[ $O == V ]]; then  #Normal report size
            #         RN    ST PART  N   S  WUG  UAG
             printf "%s %16.16s%9s%12s%6s%16s%25s  %s\n" "$tab" \
                      $RN    ${r[$i,11]} $PART      ${r[$i,5]} "$start_time" "$WAITorUSED_Duration" "$UAG"
                 #    $RN    ${r[$i,11]} $PART      ${r[$i,3]} "$start_time" "$WAITorUSED_Duration" "$UAG"
                 #${r[$i,0]} ${r[$i,11]} $PART      ${r[$i,3]} "$start_time" "$WAITorUSED_Duration" "$UAG"
                 #      |         |             |     |           |           /     /     |         | |   \
                 #  Res Name    State   Partition Nodes [Start M-D h:m] [Wait:|Used:]  Duration [Usr:|Acct:|Grp]
                 #replace_co INACTIVE  developmet    36    12-19 08:00   W:  4-12:38  369-21:27  U: milfeld
                 #      DAOS   ACTIVE        null     4    12-19 08:00   W:  1-01:02    1-00:00  U: milfeld,cazes
                 #234567890|23456789|12345678901|34567|90123456789012|4567890123456|8901234567|9012345678901234567890
                 #     11      9         12        6        15        <           25         >
       continue
     fi

     reg="\\b$USER\\b"; [[ $UAG =~ $reg ]] && UAG="U: ${USER}" && found_user=yes && my_ress+=(${r[$i,0]} )
     for nam in ${proj_names[@]}; do
       reg="\\b$nam\\b"; [[ $UAG =~ $reg ]] && UAG_list+=(${nam}) && found_project=yes
     done
     [[ ${#UAG_list[@]} -gt 0 ]] && UAG="A: ${UAG_list[@]}" && my_ress+=(${r[$i,0]})  #should not be multiple Accts; but JIC
     
     if [[ $O == N ]]; then  #Normal report size
     
        # Shorten STATE, PARTITION and User/Acct list for normal report
     
        STATE=${r[$i,11]/INACTIVE/INACTV}  # Shortened
        [[ ${#PART}        -gt  8 ]] && PART="${PART:0:7}."
        [[ ${#UAG_list[@]} -gt  0 ]] && UAG="A: ${UAG_list[@]}"  #should not be multiple Accts; but JIC
        [[ ${#startime}    -gt 11 ]] && PART="${startime:-11}."
     
        [[ $found_user != yes ]] && [[ found_project != yes ]] &&  UAG="NOT YOUR RES."
     
      #  [[ $uses_grp_access != yes ]] && [[ $O == N ]] && ACCESS="[Usr: | Acct: ]"
      #  [[ $uses_grp_access == yes ]] && [[ $O == N ]] && ACCESS="[Usr:|Acct:|G:]"
      #  echo " RESERVATION_NAME  STATE PARTITION [START M-D h:m] [Wait:|Used:]  DURATION $ACCESS"
            #         RN    ST PART   S  WUG  UAG
             printf "%s %16.16s%7s%10s%15s%25s  %s\n" "$tab" \
                      $RN  $STATE  $PART "$start_time" "$WAITorUSED_Duration" "$UAG"
     fi

   done
   if [[ $O == T ]]; then  #Terse Report
     if [[ ${#my_ress[@]}  == 0 ]]; then
        echo "RESERVATIONS for you:"
        tab=$space10
        echo "$tab NONE"
     else
        echo "RESERVATIONS"  
        tab=$space10
        echo "$tab ${my_ress[@]} (scontrol show res for details)"
     fi
   fi

exit 0
}
 

# === 09_Blocked_users ===
09_Blocked_users(){

# @TACC searches tacc_filter_options for blocked $USER.
# If found print failure, and message if it exists.
# See example of blocked_user line and message.
# non-TACC sites need to interact with their ACL mechanism.
# Based on Sanitytool's sanitycheck. Written and revised. 
#                                   2025-08-01 Kent Milfeld

#TODO Search for message within range of queue_acls/public

[[ $# != 1 ]] && O=N    #Command line options T=terse,v=Verbose, default Normal
[[ $1 == t ]] && O=T 
[[ $1 == v ]] && O=V 

space='          '  tab=""
STATUS=0

host_name=`hostname -A`
for sys in frontera vista stampede ls6; do
  [[ $host_name =~ $sys ]] && AT_TACC=yes TACC_SYS=$sys
done

if [[ $AT_TACC == yes ]]; then
  ACL_DIR=/etc/slurm
  filter_path=$ACL_DIR/tacc_filter_options
  
  # Get the beginning and end (next ^[tacc_filter sentinel) 
  # of the tacc-file/queue_acls/public section
  begin_ln=`grep -n '\[tacc_filter/queue_acls/public\]' $filter_path | sed 's/:.*//'`
  all_ln_nos=(`grep -n '^\[tacc_filter' $filter_path | sed 's/:.*//'` )
  for i in ${all_ln_nos[@]}; do
    [[ $i -gt $begin_ln ]] && end_ln=$i && break
  done

  # if "ALL =" line continue, else warning.  For TEST set USER to blocked user here.
  sed -n "$begin_ln,$end_ln p" $filter_path | grep -E '^\s*ALL\s*=' >/dev/null 2>&1
  if [[ ${PIPESTATUS[1]} == 0 ]]; then

    ACL_LINE=`sed -n "$begin_ln,$end_ln p" $filter_path | grep -E '^\s*ALL\s*='`
    tmp1=${ACL_LINE#*\'}  # remove all up to and include single quote
    tmp2=${tmp1%\'*}        # remove final quote and everything after
    blocked_list=(${tmp2//\!/})        # remove exclamation characters

    reg="\\b$USER\\b"
    if [[ "${blocked_list[@]}" =~ $reg ]]; then

      reg="^#*\s*\\b$USER\\b"  # Begins with one or more (OoM) "#"'s, OoM white spaces and boundary $USER boundry
      message=`grep -E $reg $filter_path`
      status=$?

      [[ $status != 0 ]] && message="No message (reason) for blocking was included in the filter."
      echo "$space $message"
      exit 1

    else
      [[ $O == T ]] &&
        echo "BLOCKED QUEUE ACCESS"  &&
        echo "$space User $USER has access to all queues."
      [[ $O == N ]] || [[ $O == V ]] &&
        echo "BLOCKED QUEUE ACCESS"  &&
        echo "$tab $USER has access to all queues (searched $filter_path)."
    fi 
  else
    echo " NO \"ALL =\" line found in public queue acl file."
    echo "$space Even if no user found, root is usually blocked."
    echo "$space If job submission works, don't consider this a problem."
    STATUS=3
  fi
fi
exit $STATUS

# blocked sample  !! means has message
ALL = '!root !!davidcho !!dkim5'
# message sample
# kent, DISABLED, 2024-10-04, user's OSU benchmarks hiccuped the IB fabric and left 80 nodes drained with IB err    ors via jobs 48351-48353.  <JED>
}
 
clist=(01_SSH 02_Storage 03_Quotas 04_Modules 05_Compilers 06_Allocations 07_Batch 08_Reservations 09_Blocked_users) #defined for inserted functions above.
USE=functions 
 
#-----
USAGE=" $0 [t|v]  #terse|verbose"

#Command line options t=terse,v=verbose, default normal
[[ $# == 1 ]] && [[ $1 != t ]] && [[ $1 != v ]] &&  echo "$USAGE" && exit 1

  RED="\033[0;31m"
  MAG="\033[0;34m"
 CYAN="\033[0;36m"
 GRNB="\033[1;32m"
  GRN="\033[0;32m"
 REDB="\033[1;31m"
  RED="\033[0;35m"
 GLDB="\033[1;33m"
  GLD="\033[0;33m"
RESET="\033[0m"
#Black: 30, Red: 31, Green: 32, Yellow: 33, Blue: 34, Magenta: 35, Cyan: 36, and White: 37.

#   Add APP Checks HERE to clist when check files (not functions) are used.
if [[ -z $clist ]]; then
  USE=scripts
  CL_DIR=`pwd`
  CL_CHECK_DIR=$CL_DIR
  clist=( $(cd $CL_CHECK_DIR; ls -1 [0-9][0-9]*) )
fi

#   Add User Checks HERE to clist when check files (not functions) are used.
CHECKLIST_USER_DIR=`pwd`/myown
if [[ -d $CHECKLIST_USER_DIR ]]; then
   user_clist=( $(cd $CHECKLIST_USER_DIR; ls -1 [0-9][0-9]*) )
   clist=(${clist[@]} ${user_clist[@]})
fi

for check in ${clist[@]}; do

  # Indicate when User check start, and use user's checlist directory
  if [[ $check == ${user_clist[0]} ]]; then
    USE=scripts
    echo "  =========  vvv User Checklist vvv ============"
    CL_DIR=$CHECKLIST_USER_DIR
  fi

  NO=${check%%_*}       # Get prefix sequence number (e.g. prefix number of 01_SSH)
# [[ $USE == scripts   ]] && output=`$CL_DIR/$check $1` && status=$?
  [[ $USE == functions ]] && output=$($check $1)        && status=$? #function option

  if [[ $USE == scripts   ]]; then
    output=`$CL_DIR/$check $1` 
    status=$?
  fi
#output=$( ${list[@]} )

  STRING1=$( echo $output | sed -n 1p | awk '{print $1}')

    # For highlighting first word, then remove color around line1 in printf
    # word1=$( echo $output | sed -n 1p | awk '{print $1}')
    # line1=$(sed 's/'$word1'/\\e[0;36;1m'$word1'\\e[0m/' <<< $line1)
      line1=$( head -1    <<< $output)
      lines=$( tail -n +2 <<< $output)

  if [[ $status == 0 ]]; then
      printf " [${GRNB}PASS${RESET}]"
      printf " %2s "  "$NO"
      printf "${GRN}$line1${RESET}\n"
      printf "%s\n"  "$lines"
  elif [[  $status == 1 ]]; then
      echo ""           # Space failures out and colorize them
      printf " [${REDB}FAIL${RESET}]"
      printf " %2s" $NO
      printf " ${GRN}$line1${RESET}\n"
      printf "${RED}$lines${RESET}\n"
  else
      printf " [${GLDB}WARN${RESET}]"
      printf " %2s" $NO
      printf " ${GRN}$line1${RESET}\n"
      printf "${GLD}$lines${RESET}\n"
  fi

done
#STRING1=$( echo $output | sed -n 1p | awk '{print $1}')
#[[ $status == 0 ]] && output=$(sed 's/'$STRING1'/\\e[0;36;1m'$STRING1'\\e[0m/' <<< $output)
#[[ $status == 1 ]] && output=$(sed 's/'$STRING1'/\\e[0;31;1m'$STRING1'\\e[0m/' <<< $output)
#[[ $status == 2 ]] && output=$(sed 's/'$STRING1'/\\e[0;34;1m'$STRING1'\\e[0m/' <<< $output)

